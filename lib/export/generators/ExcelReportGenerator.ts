import * as XLSX from 'xlsx';
import { ReportData, ReportSection } from '../ReportBuilder';
import { ExportConfig } from '@/types/charts';

export class ExcelReportGenerator {
  private workbook: XLSX.WorkBook;

  constructor() {
    this.workbook = XLSX.utils.book_new();
  }

  async generate(
    data: ReportData,
    config: ExportConfig,
    sections: ReportSection[]
  ): Promise<Blob> {
    this.workbook = XLSX.utils.book_new();

    // Create summary sheet
    this.createSummarySheet(data);

    // Create responses sheet
    if (sections.find(s => s.id === 'data' && s.include)) {
      this.createResponsesSheet(data.responses);
    }

    // Create analytics sheet
    this.createAnalyticsSheet(data.analytics);

    // Create question metrics sheet
    this.createQuestionMetricsSheet(data.analytics.questionMetrics);

    // Create trends sheet if available
    if (data.analytics.trends && data.analytics.trends.length > 0) {
      this.createTrendsSheet(data.analytics.trends);
    }

    // Apply styling and formatting
    if (config.branding) {
      this.applyWorkbookStyling(config.branding);
    }

    // Generate Excel file
    const excelBuffer = XLSX.write(this.workbook, {
      bookType: 'xlsx',
      type: 'array'
    });

    return new Blob([excelBuffer], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });
  }

  private createSummarySheet(data: ReportData): void {
    const summaryData = [
      ['Survey Analytics Report'],
      [''],
      ['Survey Information'],
      ['Survey Title', data.surveyInfo.title],
      ['Survey ID', data.surveyInfo.id],
      ['Total Questions', data.surveyInfo.totalQuestions],
      ['Created Date', data.surveyInfo.createdAt.toLocaleDateString()],
      [''],
      ['Key Metrics'],
      ['Total Responses', data.analytics.totalResponses],
      ['Completion Rate', `${data.analytics.completionRate.toFixed(1)}%`],
      ['Average Completion Time', this.formatDuration(data.analytics.avgCompletionTime)],
      ['Response Velocity', `${Math.round(data.analytics.responseVelocity)} per day`],
      [''],
      ['Report Information'],
      ['Generated On', data.metadata.generatedAt.toLocaleDateString()],
      ['Generated At', data.metadata.generatedAt.toLocaleTimeString()],
      ['Generated By', data.metadata.generatedBy || 'System']
    ];

    const worksheet = XLSX.utils.aoa_to_sheet(summaryData);

    // Set column widths
    worksheet['!cols'] = [
      { wch: 25 }, // Column A
      { wch: 40 }  // Column B
    ];

    // Apply styling to headers
    this.styleHeaderRows(worksheet, [0, 2, 8, 14]);

    XLSX.utils.book_append_sheet(this.workbook, worksheet, 'Summary');
  }

  private createResponsesSheet(responses: any[]): void {
    if (!responses || responses.length === 0) {
      const emptySheet = XLSX.utils.aoa_to_sheet([['No response data available']]);
      XLSX.utils.book_append_sheet(this.workbook, emptySheet, 'Responses');
      return;
    }

    // Flatten response data for Excel
    const flattenedResponses = responses.map(response => {
      const flattened: any = {
        'Response ID': response.id,
        'Status': response.status || 'Unknown',
        'Started At': response.created_at ? new Date(response.created_at).toLocaleString() : '',
        'Completed At': response.completed_at ? new Date(response.completed_at).toLocaleString() : '',
        'Duration (seconds)': response.duration || '',
        'IP Address': response.ip_address || '',
        'User Agent': response.user_agent || ''
      };

      // Add answers as columns
      if (response.answers && Array.isArray(response.answers)) {
        response.answers.forEach((answer: any) => {
          const questionKey = `Q${answer.question_id || 'Unknown'}`;
          flattened[questionKey] = answer.answer_text || answer.answer_value || '';
        });
      }

      return flattened;
    });

    const worksheet = XLSX.utils.json_to_sheet(flattenedResponses);

    // Add filters to header row
    if (worksheet['!ref']) {
      worksheet['!autofilter'] = { ref: worksheet['!ref'] };
    }

    // Set column widths
    const cols = Object.keys(flattenedResponses[0] || {}).map(key => ({
      wch: Math.min(Math.max(key.length, 10), 50)
    }));
    worksheet['!cols'] = cols;

    XLSX.utils.book_append_sheet(this.workbook, worksheet, 'Responses');
  }

  private createAnalyticsSheet(analytics: any): void {
    const analyticsData = [
      ['Analytics Overview'],
      [''],
      ['Metric', 'Value', 'Description'],
      ['Total Responses', analytics.totalResponses, 'Total number of survey responses'],
      ['Completion Rate', `${analytics.completionRate.toFixed(1)}%`, 'Percentage of completed responses'],
      ['Average Completion Time', this.formatDuration(analytics.avgCompletionTime), 'Average time to complete survey'],
      ['Response Velocity', `${Math.round(analytics.responseVelocity)}`, 'Average responses per day'],
      [''],
      ['Demographics Summary'],
      ['Device Type', 'Count', 'Percentage']
    ];

    // Add device demographics if available
    if (analytics.demographics?.device) {
      const totalDeviceResponses = Object.values(analytics.demographics.device).reduce(
        (sum: number, count: any) => sum + count, 0
      );

      Object.entries(analytics.demographics.device).forEach(([device, count]) => {
        const percentage = totalDeviceResponses > 0 ? 
          ((count as number) / totalDeviceResponses * 100).toFixed(1) : '0';
        analyticsData.push([device, count, `${percentage}%`]);
      });
    }

    const worksheet = XLSX.utils.aoa_to_sheet(analyticsData);

    // Set column widths
    worksheet['!cols'] = [
      { wch: 25 }, // Column A
      { wch: 20 }, // Column B
      { wch: 40 }  // Column C
    ];

    // Style header rows
    this.styleHeaderRows(worksheet, [0, 8]);

    XLSX.utils.book_append_sheet(this.workbook, worksheet, 'Analytics');
  }

  private createQuestionMetricsSheet(questionMetrics: any[]): void {
    const metricsData = [
      ['Question Performance Metrics'],
      [''],
      ['Question ID', 'Question Text', 'Response Rate (%)', 'Avg Time (seconds)', 'Drop-off Rate (%)']
    ];

    questionMetrics.forEach(metric => {
      metricsData.push([
        metric.questionId,
        metric.question,
        metric.responseRate.toFixed(1),
        metric.avgTime || 'N/A',
        metric.dropOffRate?.toFixed(1) || 'N/A'
      ]);
    });

    const worksheet = XLSX.utils.aoa_to_sheet(metricsData);

    // Set column widths
    worksheet['!cols'] = [
      { wch: 12 }, // Question ID
      { wch: 50 }, // Question Text
      { wch: 15 }, // Response Rate
      { wch: 15 }, // Avg Time
      { wch: 15 }  // Drop-off Rate
    ];

    // Add conditional formatting for response rates
    this.addConditionalFormatting(worksheet, questionMetrics.length + 2, 2); // Response rate column

    // Style header
    this.styleHeaderRows(worksheet, [0]);

    XLSX.utils.book_append_sheet(this.workbook, worksheet, 'Question Metrics');
  }

  private createTrendsSheet(trends: any[]): void {
    const trendsData = [
      ['Response Trends'],
      [''],
      ['Date', 'Responses', 'Cumulative Total']
    ];

    let cumulative = 0;
    trends.forEach(trend => {
      cumulative += trend.value;
      trendsData.push([
        trend.timestamp.toLocaleDateString(),
        trend.value,
        cumulative
      ]);
    });

    const worksheet = XLSX.utils.aoa_to_sheet(trendsData);

    // Set column widths
    worksheet['!cols'] = [
      { wch: 12 }, // Date
      { wch: 12 }, // Responses
      { wch: 15 }  // Cumulative
    ];

    // Create a chart reference (note: actual chart creation requires additional libraries)
    worksheet['!chart'] = {
      type: 'line',
      data: {
        labels: trends.map(t => t.timestamp.toLocaleDateString()),
        datasets: [{
          label: 'Daily Responses',
          data: trends.map(t => t.value)
        }]
      }
    };

    this.styleHeaderRows(worksheet, [0]);

    XLSX.utils.book_append_sheet(this.workbook, worksheet, 'Trends');
  }

  private styleHeaderRows(worksheet: XLSX.WorkSheet, headerRows: number[]): void {
    headerRows.forEach(rowIndex => {
      const cellRef = XLSX.utils.encode_cell({ c: 0, r: rowIndex });
      if (worksheet[cellRef]) {
        worksheet[cellRef].s = {
          font: { bold: true, sz: 14 },
          fill: { fgColor: { rgb: 'E3F2FD' } }
        };
      }
    });
  }

  private addConditionalFormatting(worksheet: XLSX.WorkSheet, dataRows: number, column: number): void {
    // Note: Basic conditional formatting - more advanced formatting requires additional libraries
    for (let row = 3; row < dataRows + 3; row++) {
      const cellRef = XLSX.utils.encode_cell({ c: column, r: row });
      if (worksheet[cellRef]) {
        const value = parseFloat(worksheet[cellRef].v);
        if (value >= 90) {
          worksheet[cellRef].s = { fill: { fgColor: { rgb: 'C8E6C9' } } }; // Green
        } else if (value >= 75) {
          worksheet[cellRef].s = { fill: { fgColor: { rgb: 'FFF9C4' } } }; // Yellow
        } else if (value < 60) {
          worksheet[cellRef].s = { fill: { fgColor: { rgb: 'FFCDD2' } } }; // Red
        }
      }
    }
  }

  private applyWorkbookStyling(branding: any): void {
    // Set workbook properties
    this.workbook.Props = {
      Title: 'Survey Analytics Report',
      Subject: 'Survey Response Analysis',
      Author: 'Survey Analytics System',
      CreatedDate: new Date()
    };

    // Apply theme colors if provided
    if (branding.colors) {
      // Note: Excel theme colors would need to be applied to individual cells/styles
      // this.workbook doesn't support a Themes property directly
    }
  }

  private formatDuration(seconds: number): string {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    
    if (minutes === 0) {
      return `${remainingSeconds}s`;
    }
    
    return `${minutes}m ${remainingSeconds}s`;
  }
}